// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ES6 classes with static properties multiple components at top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

class Test1 extends React.Component {
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number
  };

  render() {
    return <h1>{this.props.name}</h1>;
  }
}

Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
class Test2 extends React.Component {
  static propTypes = {
    hello: PropTypes.node,
    world: PropTypes.bool
  };

  render() {
    return <h2>{this.props.hello}</h2>;
  }
}
Test2.metadata = {
  props: {
    hello: {
      type: _metadataHelpers.node
    },
    world: {
      type: _metadataHelpers.bool
    }
  }
};"
`;

exports[`ES6 classes with static properties simple example 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

class Test extends React.Component {
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number
  };

  onClick = () => {
    console.log('This should be ignored.');
  };

  render() {
    return <h1>{this.props.name}</h1>;
  }
}
Test.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};"
`;

exports[`ES6 classes with static properties when exported at the top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

export class Test1 extends React.Component {
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number
  };

  render() {
    return <h1>{this.props.name}</h1>;
  }
}

Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
export default class Test2 extends React.Component {
  static propTypes = {
    hello: PropTypes.node,
    world: PropTypes.bool
  };

  render() {
    return <h2>{this.props.hello}</h2>;
  }
}
Test2.metadata = {
  props: {
    hello: {
      type: _metadataHelpers.node
    },
    world: {
      type: _metadataHelpers.bool
    }
  }
};"
`;

exports[`ES6 classes without static properties multiple components at top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

class Test1 extends React.Component {
  render() {
    return <h1>{this.props.name}</h1>;
  }
}

Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
Test1.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};

class Test2 extends React.Component {
  render() {
    return <h2>{this.props.hello}</h2>;
  }
}

Test2.metadata = {
  props: {
    hello: {
      type: _metadataHelpers.node
    },
    world: {
      type: _metadataHelpers.bool
    }
  }
};
Test2.propTypes = {
  hello: PropTypes.node,
  world: PropTypes.bool
};"
`;

exports[`ES6 classes without static properties simple example 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

class Test extends React.Component {
  render() {
    return <h1>{this.props.name}</h1>;
  }
}

Test.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
Test.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};"
`;

exports[`ES6 classes without static properties when exported at the top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

export class Test1 extends React.Component {
  render() {
    return <h1>{this.props.name}</h1>;
  }
}

Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
Test1.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};

export default class Test2 extends React.Component {
  render() {
    return <h2>{this.props.hello}</h2>;
  }
}

Test2.metadata = {
  props: {
    hello: {
      type: _metadataHelpers.node
    },
    world: {
      type: _metadataHelpers.bool
    }
  }
};
Test2.propTypes = {
  hello: PropTypes.node,
  world: PropTypes.bool
};"
`;

exports[`PropTypes can be imported under a different name 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import t from 'prop-types';

function Test(props) {
  return <h1>{props.name}</h1>;
}Test.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
;

Test.propTypes = {
  name: t.string.isRequired,
  age: t.number
};"
`;

exports[`PropTypes can be required under a different name 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

const typ = require('prop-types');

function Test(props) {
  return <h1>{props.name}</h1>;
}Test.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
;

Test.propTypes = {
  name: typ.string.isRequired,
  age: typ.number
};"
`;

exports[`functional components (arrow expression) multiple components at top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

const Test1 = props => <h1>{props.name}</h1>;

Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
Test1.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};

const Test2 = props => <h2>{props.hello}</h2>;

Test2.metadata = {
  props: {
    hello: {
      type: _metadataHelpers.node
    },
    world: {
      type: _metadataHelpers.bool
    }
  }
};
Test2.propTypes = {
  hello: PropTypes.node,
  world: PropTypes.bool
};"
`;

exports[`functional components (arrow expression) simple example 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

const Test = props => <h1>{props.name}</h1>;

Test.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
Test.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};"
`;

exports[`functional components (arrow expression) when exported at the top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

export const Test1 = props => <h1>{props.name}</h1>;

Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
Test1.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};

export default Test2 = props => <h2>{props.hello}</h2>;

Test2.propTypes = {
  hello: PropTypes.node,
  world: PropTypes.bool
};"
`;

exports[`functional components (function declaration) multiple components at top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

function Test1(props) {
  return <h1>{props.name}</h1>;
}Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
;

Test1.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};

function Test2(props) {
  return <h2>{props.hello}</h2>;
}Test2.metadata = {
  props: {
    hello: {
      type: _metadataHelpers.node
    },
    world: {
      type: _metadataHelpers.bool
    }
  }
};
;

Test2.propTypes = {
  hello: PropTypes.node,
  world: PropTypes.bool
};"
`;

exports[`functional components (function declaration) simple example 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

function Test(props) {
  return <h1>{props.name}</h1>;
}Test.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
;

Test.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};"
`;

exports[`functional components (function declaration) when exported at the top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

export function Test1(props) {
  return <h1>{props.name}</h1>;
}Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
;

Test1.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};

export default function Test2(props) {
  return <h2>{props.hello}</h2>;
}Test2.metadata = {
  props: {
    hello: {
      type: _metadataHelpers.node
    },
    world: {
      type: _metadataHelpers.bool
    }
  }
};
;

Test2.propTypes = {
  hello: PropTypes.node,
  world: PropTypes.bool
};"
`;

exports[`functional components (function expression) multiple components at top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

const Test1 = function (props) {
  return <h1>{props.name}</h1>;
};

Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
Test1.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};

const Test2 = function (props) {
  return <h2>{props.hello}</h2>;
};

Test2.metadata = {
  props: {
    hello: {
      type: _metadataHelpers.node
    },
    world: {
      type: _metadataHelpers.bool
    }
  }
};
Test2.propTypes = {
  hello: PropTypes.node,
  world: PropTypes.bool
};"
`;

exports[`functional components (function expression) simple example 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

const Test = function (props) {
  return <h1>{props.name}</h1>;
};

Test.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
Test.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};"
`;

exports[`functional components (function expression) when exported at the top level 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import PropTypes from 'prop-types';

export const Test1 = function (props) {
  return <h1>{props.name}</h1>;
};

Test1.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
Test1.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};

export default Test2 = function (props) {
  return <h2>{props.hello}</h2>;
};

Test2.propTypes = {
  hello: PropTypes.node,
  world: PropTypes.bool
};"
`;

exports[`helpers name is always unique 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import t from 'prop-types';

const metadataHelpers = 'some other variable...';

function Test(props) {
  return <h1>{props.name}</h1>;
}Test.metadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
;

Test.propTypes = {
  name: t.string.isRequired,
  age: t.number
};"
`;

exports[`metadata property name can be configured 1`] = `
"var _metadataHelpers = function () {
  function makeFuncType(type, optionsName) {
    return function (options) {
      var opts = {};
      opts[optionsName] = options;
      return Object.assign({
        type: type,
        required: false
      }, opts);
    };
  }

  var t = {};
  t.string = {
    type: 'string',
    required: false
  };
  t.number = {
    type: 'number',
    required: false
  };
  t.bool = {
    type: 'bool',
    required: false
  };
  t.func = {
    type: 'func',
    required: false
  };
  t.object = {
    type: 'object',
    required: false
  };
  t.symbol = {
    type: 'symbol',
    required: false
  };
  t.array = {
    type: 'array',
    required: false
  };
  t.node = {
    type: 'node',
    required: false
  };
  t.element = {
    type: 'element',
    required: false
  };
  t.any = {
    type: 'any',
    required: false
  };
  t.oneOf = makeFuncType('oneOf', 'possibleValues');
  t.instanceOf = makeFuncType('instanceOf', 'constructor');
  t.arrayOf = makeFuncType('arrayOf', 'elementType');
  t.objectOf = makeFuncType('objectOf', 'valueType');
  t.oneOfType = makeFuncType('oneOfType', 'possibleTypes');
  t.shape = makeFuncType('shape', 'innerTypes');

  t.isRequired = function (type) {
    return Object.assign({}, type, {
      required: true
    });
  };

  return t;
}();

import t from 'prop-types';

function Test(props) {
  return <h1>{props.name}</h1>;
}Test.__customMetadata = {
  props: {
    name: {
      type: _metadataHelpers.isRequired(_metadataHelpers.string)
    },
    age: {
      type: _metadataHelpers.number
    }
  }
};
;

Test.propTypes = {
  name: t.string.isRequired,
  age: t.number
};"
`;

exports[`when no components found at all 1`] = `
"
import SomethingElse from 'something-else';
import { someNonDefaultExport } from 'prop-types';
const Hmm = require('hmmm');

module = \\"This should be ignored.\\";
SomethingElse.aProperty = \\"This should also be ignored.\\";

var foo = 1;
if (foo) console.log(foo);
console.log('This will be ignored.');

class NotAComponent extends SomethingElse {
  static notPropTypes = 47;
  static propTypes = \\"A string property called propTypes?\\";

  method1() {
    console.log('hello!');
  }
}"
`;

exports[`when no components found at top level 1`] = `
"
import PropTypes from 'prop-types';

function wrapperFunction() {
  const InnerComponent1 = () => <h1>hello, world</h1>;
  InnerComponent1.propTypes = {
    test: PropTypes.string
  };

  const InnerComponent2 = function () {
    return <h1>hello, world</h1>;
  };
  InnerComponent2.propTypes = {
    test: PropTypes.string
  };

  function InnerComponent3() {
    return <h1>hello, world</h1>;
  }
  InnerComponent3.propTypes = {
    test: PropTypes.string
  };

  class InnerComponent4 extends React.Component {
    static propTypes = {
      test: PropTypes.string
    };

    render() {
      return <h1>hello, world</h1>;
    }
  }
}"
`;
